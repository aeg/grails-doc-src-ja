
h1. Document Translation Report.

* *File Count* - 272
* *Done* - 190
* *TODO* - 80
* *Not found or new* - 2

h2. Original document updated after translation.:

*./guide/gettingStarted/runningAnApplication.gdoc*

{code}
19 : | Application loaded in interactive mode. Type 'stop-app' to shutdown.
21 : grails> stop-app
25 : | Application loaded in interactive mode. Type 'stop-app' to shutdown.
{code}

*./guide/theWebLayer/controllers/dataBinding.gdoc*

{code}
242: The [BindUsing|api:org.grails.databinding.BindUsing] annotation may be used to define a custom binding mechanism for a particular field in a class.  Any time data binding is being applied to the field the closure value of the annotation will be invoked with 2 arguments.  The first argument is the object that data binding is being applied to and the second argument is a @Map@ which is the data source for the data binding.  The value returned from the closure will be bound to the property.  The following example would result in the upper case version of the @name@ value in the source being applied to the @name@ field during data binding.
245: import org.grails.databinding.BindUsing
247: class SomeClass \{
248:     @BindUsing(\{
249:         obj, source -> source['name']?.toUpperCase()
250:     \})
251:     String name
255: The [BindUsing|api:org.grails.databinding.BindUsing] annotation may be used to define a custom binding mechanism for all of the fields on a particular class. When the annotation is applied to a class, the value assigned to the annotation should be a class which implements the [BindingHelper|api:org.grails.databinding.BindingHelper] interface.  An instance of that class will be used any time a value is bound to a property in the class that this annotation has been applied to. 
258: @BindUsing(SomeClassWhichImplementsBindingHelper)
259: class SomeClass \{
260:     String someProperty
261:     Integer someOtherProperty
267: The binder will do a lot of type conversion automatically.  Some applications may want to define their own mechanism for converting values and a simple way to do this is to write a class which implements [ValueConverter|api:org.grails.databinding.converters.ValueConverter] and register an instance of that class as a bean in the Spring application context.
270: package com.myapp.converters
272: import org.grails.databinding.converters.ValueConverter
274: /**
275:  * A custom converter which will convert String of the
276:  * form 'city:state' into an Address object.
277:  */
278: class AddressValueConverter implements ValueConverter \{
280:     def convert(value) \{
281:         def pieces = value.split(':')
282:         new com.myapp.Address(city: pieces[0], state: pieces[1])
283:     \}
285:     Class<?> getTargetType() \{
286:         com.myapp.Address
287:     \}
291: An instance of that class needs to be registered as a bean in the Spring application context.  The bean name is not important.  All beans that implemented ValueConverter will be automatically plugged in to the data binding process.
294: // grails-app/conf/spring/resources.groovy
296: beans = \{
298:     addressConverter com.myapp.converters.AddressValueConverter
306: class Person \{
307:     String firstName
308:     Address homeAddress
311: class Address \{
312:     String city
313:     String state
316: def person = new Person()
317: person.properties = [firstName: 'Jeff', homeAddress: "O'Fallon:Missouri"]
318: assert person.firstName == 'Jeff'
319: assert person.homeAddress.city = "O'Fallon"
320: assert person.homeAddress.state = 'Missouri'
325: A custom date format may be specified to be used when binding a String to a Date value by applying the [BindingFormat|api:org.grails.databinding.BindingFormat] annotation to a Date field.
328: import org.grails.databinding.BindingFormat
330: class Person \{
331:     @BindingFormat('MMddyyyy')
332:     Date birthDate
338: You may supply your own handler for the [BindingFormat|api:org.grails.databinding.BindingFormat] annotation by writing a class which implements the [FormattedValueConverter|api:org.grails.databinding.converters.FormattedValueConverter] interface and regiserting an instance of that class as a bean in the Spring application context.  Below is an example of a trivial custom String formatter that might convert the case of a String based on the value assigned to the BindingFormat annotation.
341: package com.myapp.converters
343: import org.grails.databinding.converters.FormattedValueConverter
345: class FormattedStringValueConverter implements FormattedValueConverter \{
346:     def convert(value, String format) \{
347:         if('UPPERCASE' == format) \{
348:             value = value.toUpperCase()
349:         \} else if('LOWERCASE' == format) \{
350:             value = value.toLowerCase()
351:         \}
353:     \}
355:     Class getTargetType() \{
356:         // specifies the type to which this converter may be applied
357:         String
358:     \}
362: An instance of that class needs to be registered as a bean in the Spring application context.  The bean name is not important.  All beans that implemented FormattedValueConverter will be automatically plugged in to the data binding process.
365: // grails-app/conf/spring/resources.groovy
367: beans = \{
369:     formattedStringConverter com.myapp.converters.FormattedStringValueConverter
376: With that in place the BindUsing annotation may be applied to String fields to inform the data binder to take advantage of the custom converter.
379: import org.grails.databinding.BindingFormat
381: class Person \{
382:     @BindingFormat('UPPERCASE')
383:     String someUpperCaseString
385:     @BindingFormat('LOWERCASE')
386:     String someLowerCaseString
388:     String someOtherString
{code}

*./guide/introduction/whatsNew23.gdoc*

{code}
15 : The @create-app@ command will now by default generate the command line grailsw wrapper for newly created applications.  The @--skip-wrapper@ switch may be used to prevent the wrapper from being generated.
{code}

*./guide/gettingStarted/requirements.gdoc*

{code}
9  : \{note\}
10 : A JDK is required in your Grails development environment. A JRE is not sufficient.
11 : \{note\}
{code}

*./guide/theWebLayer/contentNegotiation.gdoc*

{code}
25 : Let's say a controller action can return a resource in a variety of formats: HTML, XML, and JSON. What format will the client get? The easiest and most reliable way for the client to control this is through a @format@ URL parameter.
27 : So if you, as a browser or some other client, want a resource as XML, you can use a URL like this:
30 : http://my.domain.org/books?format=xml
33 : The result of this on the server side is a @format@ property on the @response@ object with the value @xml@ . You could code your controller action to return XML based on this property, but you can also make use of the controller-specific @withFormat()@ method:
36 : import grails.converters.JSON
46 :             json \{ render books as JSON \}
53 : In this example, Grails will only execute the block inside @withFormat()@ that matches the requested content type. So if the preferred format is @html@ then Grails will execute the @html()@ call only. Each 'block' can either be a map model for the corresponding view (as we are doing for 'html' in the above example) or a closure. The closure can contain any standard action code, for example it can return a model or render content directly.
55 : There is a special format, "all", that is handled differently from the explicit formats. If "all" is specified (normally this happens through the Accept header - see below), then the first block of @withFormat()@ is executed. You should not add an explicit "all" block. In the above example, a format of "all" will trigger the @html@ handler.
69 : which simply means anything. However, newer browsers send more interesting values such as this one sent by Firefox 3:
72 : text/xml, application/xml, application/xhtml+xml, text/html;q=0.9, \
73 :     text/plain;q=0.8, image/png, */*;q=0.5
76 : This particular accept header is unhelpful because it indicates that XML is the preferred response format whereas the user is really expecting HTML. That's why Grails ignores the accept header by default. However, non-browser clients are typically more specific in their requirements and can send accept headers such as
79 : application/json
82 : If you want to support such clients and their accept headers, then simply add (or change) the @grails.mime.use.accept.header@ setting in @Config.groovy@ :
85 : grails.mime.use.accept.header = true
88 : With this setting, Grails parses the incoming accept header and sets the appropriate value for the @format@ response property. For example, if it sees the accept header above ('application/json') it will set @format@ to @json@ as you'd expect. And of course this works with the @withFormat()@ method in just the same way as when the @format@ URL parameter is set (although the URL parameter takes precedence).
90 : An accept header of '\*/\*' results in a value of @all@ for the @format@ property.
93 : If you enable accept header parsing, it's usually best to handle XML and JSON responses in a different action from the HTML ones due to the problems with various browsers. You can then use @withFormat()@ exclusively for the REST interface and avoid it for actions that render the normal HTML pages.
{code}

*./guide/webServices/SOAP.gdoc*

{code}
1  : Grails does not feature SOAP support out-of-the-box, but there are several plugins that can help for both producing SOAP servers and calling SOAP web services.
5  : To call SOAP web services there are generally 2 approaches taken, one is to use a tool to generate client stubs, the other is to manually construct the SOAP calls. The former can be easier to use, but the latter provides more flexibility / control.
7  : The [CXF client plugin|http://grails.org/plugin/cxf-client] uses the CXF framework, which includes a @wsdl2java@ tool for generating a client. There is nothing Groovy/Grails specific here in the generated code as it simply provides a Java API which you can invoke to call SOAP web services.
9  : See the documentation on the [CXF client plugin|https://github.com/ctoestreich/cxf-client] for further information.
11 : Alternatively, if you prefer more control over your SOAP calls the [WS-Lite library|https://github.com/jwagenleitner/groovy-wslite] is an excellent choice and features a [Grails plugin|http://grails.org/plugin/wslite]. You have more control over the SOAP requests sent, and since Groovy has fantastic support for building and parsing XML it can be very productive approach. 
13 : Below is an example of a SOAP call with wslite:
16 : withSoap(serviceURL: 'http://www.holidaywebservice.com/Holidays/US/Dates/USHolidayDates.asmx') \{
17 :     def response = send \{
18 :         body \{
19 :             GetMothersDay(xmlns: 'http://www.27seconds.com/Holidays/US/Dates/') \{
20 :                 year(2011)
21 :             \}
22 :         \}
24 :     println response.GetMothersDayResponse.GetMothersDayResult.text()
28 : It is not recommended that you use the [GroovyWS|http://groovy.codehaus.org/GroovyWS] library, it pulls in many dependencies which increases the likelihood of conflicts. The WSlite library provides a far simpler and easier to use solution.
32 : Again, Grails does not have direct support for exposing SOAP web services, however if you wish to expose a SOAP service from your application then the [CXF plugin|http://grails.org/plugin/cxf] (not to be confused with the cxf-client plugin), provides an easy way to do so.
34 : Typically it involves taking a Grails service and adding 'expose'-style configuration, such as the below:
37 :   static expose = EndpointType.JAX_WS_WSDL
38 :   //your path (preferred) or url to wsdl
39 :   static wsdl = 'org/grails/cxf/test/soap/CustomerService.wsdl' 
42 : Please refer to the [documentation of the plugin|https://github.com/thorstadt/grails-cxf#soap] for more information.
{code}

*./guide/plugins/repositories.gdoc*

{code}
34 : Grails 1.3 and above use Ivy under the hood to resolve plugin dependencies. The mechanism for defining additional plugin repositories is largely the same as [defining repositories for JAR dependencies|guide:dependencyResolution]. For example you can define a remote Maven repository that contains Grails plugins using the following syntax in @grails-app/conf/BuildConfig.groovy@:
{code}

*./guide/theWebLayer/ajax/ajaxSupport/ajaxEvents.gdoc*

{code}
21 : You can simply refer to the @XMLHttpRequest@ variable to obtain the request:
32 :               onFailure="fireMe(XMLHttpRequest)">Ajax Link</g:remoteLink>
{code}

*./guide/upgradingFromPreviousVersionsOfGrails.gdoc*

{code}
3  : * Dependency resolution has been changed to *only* use data from the POMs to resolve, this can impact plugins and you may need to republish a plugin with corrected dependency data
53 : Grails 2.2 ships with Groovy 2.0 which has some language level changes that may require changes to your code or plugins that you use.
57 : Grails 2.2 no longer uses the BuildConfig of the plugin for dependency resolution and *only* uses data provided by POMs, this may impact some plugins that had previously incorrectly 
58 : specified dependency information.
60 : If you don't want to immediately deal with the changes necessary to upgrade, then you can open @BuildConfig@ and set the @legacyResolve@ settings to true:
63 : grails.project.dependency.resolution = \{    
64 :     ...
65 :     legacyResolve false 
66 :     ...
70 : This is not recommended however, as it will re-enable the previous behavior of using both POM data and BuildConfig to resolve dependencies. The most commmon problem you will face is with plugins that express their dependencies in a scope that is not valid inside a POM (example: "build" scope).
72 : Plugins like this will need to be re-publish with a corrected scope of "compile". If you then specify the plugin as "build" scope in your application, transitive compile and runtime scoped dependencies will be converted to "build" scope as well.
{code}

*./guide/theWebLayer/ajax.gdoc*

{code}
3  : \{note\}
4  : Note: JavaScript examples use the jQuery library.
5  : \{note\}
{code}

*./guide/GORM/advancedGORMFeatures/ormdsl/caching.gdoc*

{code}
7  :     cache.use_second_level_cache=true
8  :     cache.use_query_cache=true
9  :     cache.provider_class='org.hibernate.cache.EhCacheProvider'
{code}

*./guide/theWebLayer/ajax/ajaxOnTheServer.gdoc*

{code}
50 : function updateBook(data) \{
51 :     $("#book" + data.id + "_title").html( data.title );
53 : </g:javascript>
54 : <g:remoteLink action="showBook" id="$\{book.id\}" onSuccess="updateBook(data)">
81 : function updateBook(data) \{
82 :     var id = $(data).find("book").attr("id");
83 :     $("#book" + id + "_title").html( $(data).find("title").text() );
85 : </g:javascript>
86 : <g:remoteLink action="showBook" id="$\{book.id\}" onSuccess="updateBook(data)">
104:     String title = b.title.encodeAsJavaScript()
105:     render "\$('#book$\{b.id\}_title').html('$\{title\}');"
{code}

*./guide/gettingStarted/aHelloWorldExample.gdoc*

{code}
1  : Let's now take the new project and turn it into the classic "Hello world\!" example. First, change into the "helloworld" directory you just created and start the Grails interactive console:
7  : You should see a prompt that looks like this:
11 : What we want is a simple page that just prints the message "Hello World\!" to the browser. In Grails, whenever you want a new page you just create a new controller action for it. Since we don't yet have a controller, let's create one now with the [create-controller|commandLine] command:
16 : Don't forget that in the interactive console, we have auto-completion on command names. So you can type "cre" and then press <tab> to get a list of all @create\-\*@ commands. Type a few more letters of the command name and then <tab> again to finish.
18 : The above command will create a new [controller|guide:controllers] in the @grails-app/controllers/helloworld@ directory called @HelloController.groovy@. Why the extra @helloworld@ directory? Because in Java land, it's strongly recommended that all classes are placed into packages, so Grails defaults to the application name if you don't provide one. The reference page for [create-controller|commandLine] provides more detail on this.
20 : We now have a controller so let's add an action to generate the "Hello World\!" page. The code looks like this: 
27 :     def index() \{
33 : The action is simply a method. In this particular case, it calls a special method provided by Grails to [render|tags] the page.
35 : Job done. To see your application in action, you just need to start up a server with another command called [run-app|commandLine]:
40 : This will start an embedded server on port 8080 that hosts your application. You should now be able to access your application at the URL [http://localhost:8080/helloworld/|http://localhost:8080/helloworld/] - try it\!
43 : If you see the error "Server failed to start for port 8080: Address already in use", then it means another server is running on that port. You can easily work around this by running your server on a different port using @-Dserver.port=9090 run-app@. '9090' is just an example: you can pretty much choose anything within the range 1024 to 49151.
46 : The result will look something like this:
50 : This is the Grails intro page which is rendered by the @grails-app/view/index.gsp@ file. It detects the presence of your controllers and provides links to them. You can click on the "HelloController" link to see our custom page containing the text "Hello World\!". Voila\! You have your first working Grails application.
52 : One final thing: a controller can contain many actions, each of which corresponds to a different page (ignoring AJAX at this point). Each page is accessible via a unique URL that is composed from the controller name and the action name: /<appname>/<controller>/<action>. This means you can access the Hello World page via [/helloworld/hello/index|http://localhost:8080/helloworld/hello/index], where 'hello' is the controller name (remove the 'Controller' suffix from the class name and lower-case the first letter) and 'index' is the action name. But you can also access the page via the same URL without the action name: this is because 'index' is the _default action_. See the end of the [controllers and actions|guide:understandingControllersAndActions] section of the user guide to find out more on default actions.
{code}

*./guide/theWebLayer/controllers/commandObjects.gdoc*

{code}
1  : Grails controllers support the concept of command objects. A command object is a class that is used in conjunction with [data binding|guide:dataBinding], usually to allow validation of data that may not fit into an existing domain class.
3  : \{note\}
4  : Note: A class is only considered to be a command object when it is used as a parameter of an action.
5  : \{note\}
24 : In this example, the command object is marked with the @Validateable@ annotation. The @Validateable@ annotation allows the definition of [constraints|guide:constraints] just like in [domain classes|guide:GORM]. If the command object is defined in the same source file as the controller that is using it, Grails will automatically mark it as @Validateable@. It is not required that command object classes be validateable.
30 : Before the controller action is executed Grails will automatically create an instance of the command object class and populate its properties by binding the request parameters.  If the command object class is marked with @Validateable@ then the command object will be validated. For example:
{code}

*./guide/testing/unitTesting.gdoc*

{code}
25 : Note that you're only ever likely to use the first two explicitly. The rest are there for reference. 
{code}

*./guide/introduction/whatsNew22.gdoc*

{code}
59 : * The ability to deploy other Grails/Spring applications in parallel without conflicting dependencies
{code}

*./guide/GORM/quickStartGuide.gdoc*

{code}
21 : If you have the @dbCreate@ property set to "update", "create" or "create-drop" on your [DataSource|guide:dataSource], Grails will automatically generate/modify the database tables for you.
{code}

*./guide/plugins/creatingAndInstallingPlugins.gdoc*

{code}
11 : Make sure the plugin name does not contain more than one capital in a row, or it won't work. Camel case is fine, though.
113: You can specify what to exclude in addition to the default excludes by adding elements to the @pluginExcludes@ descriptor property (described below). In addition, there are two ways to configure the contents of the plugin ZIP or JAR file.
115: One is to create an event handler for the @CreatePluginArchiveStart@ event, which is fired after all of the plugin files have been copied to the staging directory. By adding an event handler you can add, modify, or delete files as needed. Add the handler to @_Events.groovy@ in the @scripts@ directory, for example
118: eventCreatePluginArchiveStart = \{ stagingDir ->
119:    // update staging directory contents here
123: You can customize the location of the staging directory with the @grails.project.plugin.staging.dir@ attribute in @BuildConfig.groovy@ or as  as system property. 
125: Note that there is also a @CreatePluginArchiveEnd@ event which is fired after the ZIP or JAR is packaged.
127: You can also do this work in a Closure in @BuildConfig.groovy@ with the property @grails.plugin.resources@ which is analogous to the @grails.war.resources@ property, e.g.
130: grails.plugin.resources = \{ stagingDir ->
131:    // update staging directory contents here
155: The Artifactory repository for Grails now includes all the dependencies for published plugins. So, if you are using inline plugins that have dependencies, it is necessary to do a secondary resolve because these dependencies might not be in the repository. Therefore, you should set @legacyResolve@ to @true@ in your @BuildConfig.groovy@ if you are using inline plugins with dependencies.
{code}

h2. Not done.

* ../en/guide/GORM/advancedGORMFeatures/defaultSortOrder.gdoc
* ../en/guide/GORM/advancedGORMFeatures/eventsAutoTimestamping.gdoc
* ../en/guide/GORM/advancedGORMFeatures/ormdsl/compositePrimaryKeys.gdoc
* ../en/guide/GORM/advancedGORMFeatures/ormdsl/customCascadeBehaviour.gdoc
* ../en/guide/GORM/advancedGORMFeatures/ormdsl/customHibernateTypes.gdoc
* ../en/guide/GORM/advancedGORMFeatures/ormdsl/customNamingStrategy.gdoc
* ../en/guide/GORM/advancedGORMFeatures/ormdsl/databaseIndices.gdoc
* ../en/guide/GORM/advancedGORMFeatures/ormdsl/derivedProperties.gdoc
* ../en/guide/GORM/advancedGORMFeatures/ormdsl/fetchingDSL.gdoc
* ../en/guide/GORM/advancedGORMFeatures/ormdsl/optimisticLockingAndVersioning.gdoc
* ../en/guide/GORM/domainClasses/gormAssociation/basicCollectionTypes.gdoc
* ../en/guide/GORM/domainClasses/gormAssociation/manyToMany.gdoc
* ../en/guide/GORM/domainClasses/gormAssociation/manyToOneAndOneToOne.gdoc
* ../en/guide/GORM/domainClasses/gormAssociation/oneToMany.gdoc
* ../en/guide/GORM/domainClasses/gormComposition.gdoc
* ../en/guide/GORM/domainClasses/inheritanceInGORM.gdoc
* ../en/guide/GORM/persistenceBasics/locking.gdoc
* ../en/guide/GORM/persistenceBasics/modificationChecking.gdoc
* ../en/guide/GORM/querying/criteria.gdoc
* ../en/guide/GORM/querying/detachedCriteria.gdoc
* ../en/guide/GORM/querying/hql.gdoc
* ../en/guide/async/grailsEvents.gdoc
* ../en/guide/commandLine/forkedMode.gdoc
* ../en/guide/commandLine/interactiveMode.gdoc
* ../en/guide/commandLine/wrapper.gdoc
* ../en/guide/conf.gdoc
* ../en/guide/conf/config.gdoc
* ../en/guide/conf/config/builtInOptions.gdoc
* ../en/guide/conf/config/configGORM.gdoc
* ../en/guide/conf/config/logging.gdoc
* ../en/guide/conf/configExternalized.gdoc
* ../en/guide/conf/dataSource.gdoc
* ../en/guide/conf/dataSource/JNDIDataSources.gdoc
* ../en/guide/conf/dataSource/automaticDatabaseMigration.gdoc
* ../en/guide/conf/dataSource/dataSourcesAndEnvironments.gdoc
* ../en/guide/conf/dataSource/databaseConsole.gdoc
* ../en/guide/conf/dataSource/multipleDatasources.gdoc
* ../en/guide/conf/dataSource/transactionAwareDataSourceProxy.gdoc
* ../en/guide/conf/dependencyResolution.gdoc
* ../en/guide/conf/dependencyResolution/changingDependencies.gdoc
* ../en/guide/conf/dependencyResolution/configurationsAndDependencies.gdoc
* ../en/guide/conf/dependencyResolution/debuggingResolution.gdoc
* ../en/guide/conf/dependencyResolution/dependencyReports.gdoc
* ../en/guide/conf/dependencyResolution/dependencyRepositories.gdoc
* ../en/guide/conf/dependencyResolution/dependencyResolutionCaching.gdoc
* ../en/guide/conf/dependencyResolution/inheritedDependencies.gdoc
* ../en/guide/conf/dependencyResolution/mavenIntegration.gdoc
* ../en/guide/conf/dependencyResolution/mavendeploy.gdoc
* ../en/guide/conf/dependencyResolution/pluginDependencies.gdoc
* ../en/guide/conf/dependencyResolution/pluginJARDependencies.gdoc
* ../en/guide/conf/dependencyResolution/providingDefaultDependencies.gdoc
* ../en/guide/conf/docengine.gdoc
* ../en/guide/conf/environments.gdoc
* ../en/guide/conf/versioning.gdoc
* ../en/guide/contributing.gdoc
* ../en/guide/contributing/build.gdoc
* ../en/guide/contributing/issues.gdoc
* ../en/guide/contributing/patchesCore.gdoc
* ../en/guide/contributing/patchesDoc.gdoc
* ../en/guide/hibernate.gdoc
* ../en/guide/hibernate/addingConstraints.gdoc
* ../en/guide/hibernate/mappingWithHibernateAnnotations.gdoc
* ../en/guide/hibernate/usingHibernateXMLMappingFiles.gdoc
* ../en/guide/links.yml
* ../en/guide/rewriteRules.txt
* ../en/guide/services/declarativeTransactions/transactionsRollbackAndTheSession.gdoc
* ../en/guide/spring/springdslAdditional.gdoc
* ../en/guide/spring/theBeanBuilderDSLExplained.gdoc
* ../en/guide/spring/theUnderpinningsOfGrails.gdoc
* ../en/guide/testing/integrationTesting.gdoc
* ../en/guide/testing/unitTesting/unitTestingFilters.gdoc
* ../en/guide/theWebLayer/urlmappings/namespacedControllers.gdoc
*  *(original file updated)* ../en/guide/toc.yml
* ../en/guide/validation.gdoc
* ../en/guide/validation/constraints.gdoc
* ../en/guide/validation/sharingConstraints.gdoc
* ../en/guide/validation/validatingConstraints.gdoc
* ../en/guide/validation/validationAndInternationalization.gdoc
* ../en/guide/validation/validationNonDomainAndCommandObjectClasses.gdoc
* ../en/guide/validation/validationOnTheClient.gdoc

h2. File not found (new file added) or empty file

* ../en/guide/gettingStarted.gdoc
* ../en/guide/theWebLayer.gdoc

